// DrawManager.h

#include <GL/freeglut.h>

#define WARN_OK 0
#define WARN_ELEM_OVER_ALLOCATED 1
#define WARN_INDEX_OVER_RANGE 2
#define WARN_PARAM_NOT_EXIST 4
#define WARN_ELEM_NOT_EXIST 8
#define WARN_NO_ELEMS 16
#define WARN_MEMORY_LEAK 32

// drawing structures

typedef bool drawfunc();


// simple structure to store drawable data
// generated by DrawManager
// DrawManager can be extended to allow organized drawing of object
struct drawable {
    float level;
    bool visible;
    drawfunc *draw;
};

// stores an rgb color as floats for convinience
struct rgbcolor {
   float r, g, b;
};

struct cached_img {
    unsigned char* indx;
    unsigned int height;
    unsigned int width;
    GLenum format;
    GLenum type;
};

template <typename T>
class DrawManager {
    public:
        DrawManager();
        bool addElement(T elem);
        bool addElement(T elem, int index);
        T removeElement(T elem);
        T removeElement(int index);
        void setElements(T *elements);
        T *clearElements();
        int getWarnings();
        int clearWarnings();
        virtual void loadResources() = 0;
        virtual void freeResources() = 0;
        // virtual bool setParamf(int param, float val) = 0;
        // virtual bool setParami(int param, int val) = 0;
        // virtual bool setParamb(int param, bool val) = 0;
        // virtual bool setParam(int param, void *val) = 0;
        virtual struct drawable *getDrawable() = 0;
    private:
        int warnings;
        T *elements;
        int num_elems;
        const int elems_orig_size = 32; // change this depending on the probable need
};

class BoardDrawer : public DrawManager<struct playable_card> {
    
};

// loading functions
// TODO: move image loading, freeing functions to draw_manager (or create new class for it )

int get_gl_format(upng_format frmt);
int get_gl_type(upng_format frmt);
void add_gl_props(cached_img *c, upng_format frmt);
cached_img *stack_pop();
cached_img *stack_remove(int i);
int stack_get_index(cached_img *c);
void unload_img(cached_img *c);
void unload_img(int i);
void unload_all();
cached_img *cache_image(cached_img *x, unsigned int height, unsigned int width, unsigned int pixel_depth, GLenum format, GLenum type, GLvoid *pixels);
cached_img *loadPngImg(cached_img *x, const char *pth);
upng_error get_png_error();

// drawing

void output(float x, float y, float r, float g, float b, void* font, char *string);
void draw_cached_img(struct cached_img img, float x, float y);
bool safe_draw_cached_img (struct cached_img img, float x, float y, float sx, float sy);
bool center_cached_img (struct cached_img img, float x, float y, float sx, float sy);
struct drawable drawable_from_img(struct cached_img img, float level);
void set_pallete(struct rgbcolor *rgbmap);
char *get_binary(int input);

// draw buffer

int compDrawable(const void *a, const void *b);
void sortDrawBuffer();
void loadVisibleDrawBuffer();
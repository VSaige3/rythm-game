#define IMG_BUFFER_SIZE 8*64*64


#include <stddef.h>
#include <math.h>
#include <stdbool.h>
// #include <iostream>
// #include <fstream>
#include <GL/glut.h>
#include <GL/freeglut.h>
#include "upng/upng.h"
// #include <map>
#include <string.h>

struct cached_img {
    unsigned char *indx;
    unsigned int height;
    unsigned int width;
    unsigned int pixelsize;
    GLenum format;
    GLenum type;
};



struct drawable {
    float level;
    bool visible;
    struct cached_img *data;
};

struct interactable {
    float w, h, x, y;
    struct drawable visual;
};

// stores an rgb color as floats for convinience
struct rgbcolor {
   float r, g, b;
};



//don't need this, ignore for now
/*
rotateImage
rotates the image passed in and stores it back into the same address
transforms from point (x, y) to (x+cos(θ), y+sin(θ))

image {struct cached_img*} - a pointer to the image format object. This is where the transformed image will be stored
angle {float} - a number of radians to rotate the image, counterclockwise
*/
char *rotateImage(struct cached_img *image, float angle);

char *rotate90Clockwise(struct cached_img *image);

struct cached_img create_empty_image();
struct cached_img create_empty_image(int height, int wth);
struct cached_img create_empty_image_f(int height, int width, GLenum format, GLenum type);

/*
cache_image
stores an image in memory for easy access
*/
struct cached_img *cache_image(struct cached_img *x, unsigned int height, unsigned int width, unsigned int pixel_depth, GLenum format, GLenum type, GLvoid *pixels);

/*
loadPngImg
loads a png file and adds it to the image stack. returns its location
x {struct cached_img&} - the destination for it to be loaded into
pth {const char&} - the path of the image

return {struct cached_img} - the image's index in the stack
*/
struct cached_img *loadPngImg(struct cached_img *x, const char *pth);

/*
unloadPngImg
frees the data reserved for an image to prevent memory leaks
indx {int} - the index of the struct cached_img to unload
*/
struct cached_img *unloadPngImg(int indx);

/*
unloadAll
frees all image data
*/
struct cached_img **unloadAllImgs();

/*
closeAll
frees all images and then deletes them
*/
void closeAllImgs();

/*
get_png_error
retrieves latest error generated by upng image loading
*/
upng_error get_png_error();

void output(float x, float y, float r, float g, float b, void* font, const char *string);

/* draws img with no transformations applied */
void draw_cached_img (struct cached_img img);

/*
safe_draw_cached_img
img {struct cached_img} - the image to draw
x {float} - x position of the image
y {float} - y position of the image
sx {float} - amount the image is streched in the x direction
sy {float} - amount the image is streched in the y direction

draws the specified image while preserving the raster position and zoom
*/
bool safe_draw_cached_img (struct cached_img img, float x, float y, float sx, float sy);

bool center_cached_img (struct cached_img img, float x, float y, float sx, float sy, float window_width, float window_height);

/*
getFormatDepth
gets the pixel depth of a format. Only covers simple image formats (eg. ones present in png images)
*/
int getFormatDepth(GLenum format, GLenum type);

/*
flip_image
flips an image vertically so it loads correctly in opengl
h {uint} - height in pixels
w {uint} - width in pixels
d {uint} - number of bytes per pixel
*/
unsigned char *flip_image(unsigned char *orig, unsigned int h, unsigned int w, unsigned int d);

unsigned char *flip_image_d(struct cached_img target);